# Määrittelydokumentti: LARPCaster-työkalu

LARPCaster on Javalla toteutettu ja tekstimuotoisella käyttöliittymällä varustettu työkalu liveroolipelien hahmojaon optimointiin.

## Taustaa
LARPCaster-työkalu on tarkoitettu auttamaan liveroolipelien järjestäjiä eli pelinjohtajia pelaajavalintojen ja hahmojaon tekemisessä. Suomalaisissa liveroolipeleissä on yleensä tapana, että pelaajat ilmoittautuvat peliin täyttämällä lomakkeen, jossa kysytään henkilötietojen lisäksi myös lukuisia kysymyksiä pelityyliin ja hahmoon liittyvistä mieltymyksistä ja toiveista, jotta kullekin pelaajalle voidaan valita mahdollisimman hyvin tälle sopiva hahmo. Perinteisesti pelinjohto on lukenut ilmoittautumislomakkeet läpi manuaalisesti ja yrittäneet jakaa valmiiksi kirjoitetut hahmot pelaajille siten, että kukin pelaaja saisi mahdollisimman hyvin toiveitaan vastaavan hahmon. Tämä on kuitenkin hyvin hankalaa ja työlästä, ja edellyttää että hahmojakoon osallistuvat pelinjohtajat tuntevat myös hahmot hyvin, mikä saattaa aiheuttaa ongelmia suuremmissa peleissä joissa hahmoja on ollut kirjoittamassa suuri määrä ihmisiä ja hyvin harvalla on käsitystä muista kuin itse kirjoittamistaan hahmoista.

Vaikka suuri osa ilmoittautumislomakkeista perustuu edelleen kysymyksiin joihin pelaajat vastaavat vapaamuotoisesti kirjoittamalla, ovat myös erilaiset monivalintakysymykset ja muut yksiselitteistä dataa tuottavat kysymykset yleistyneet viime vuosina. Tällaisten kysymysten käyttö avaa mahdollisuuden myös vastausten laskennalliselle analyysille ja parhaimmillaan hyvin valitut ja muotoillut monivalinta-, kyllä/ei- ja arvoasteikkokysymykset tarjoavat pelinjohdolle hyvin täsmällistä tietoa siitä, mitkä pelin hahmoista mahdollisesti sopivat kullekin pelaajalle. Kun näihin vastauksiin yhdistetään hahmojen kirjoittajien kustakin hahmosta täyttämän vastaavan mutta hahmon ominaisuuksia ja pelisisältöä kuvaavan kyselyn data, tulee mahdolliseksi vertailla pelaajan toiveita ja hahmon piirteitä matemaattisesti. Näiden mahdollisuuksien hyödyntämiseksi olen viimeisten kahden vuoden aikana kehittänyt järjestelmän, joka perustuu (toistaiseksi Google Forms -muotoisten lomakkeiden XML-muotoon muunnetun mutta tulevaisuudessa tätä varten erikseen kehitetyn ilmoittautumisjärjestelmän tuottaman) vastausdatan puoliautomaattiseen analyysiin ja laskee annettujen parametrien perusteella yhteensopivuusprosentin kullekin hahmon ja pelaajan yhdistelmälle. 

Menetelmää ja sen tuottamaa tietoa on toistaiseksi käytetty kolmessa pelissä (Juhannustanssit (2017), Avalon: Murroksen aika (2018) ja Odysseus (2019)) perinteisen pelinjohdon suorittaman hahmojaon tukena. Yhteensopivuusprosenttien avulla on ollut mahdollista karsia automaattisesti pois pelaajan toiveisiin täysin sopimattomat hahmot ja keskittää huomio parhaiten sopiviin hahmoihin, mikä on helpottanut pelinjohdon työtä huomattavasti, etenkin Odysseuksen kaltaisissa suuremmissa peleissä. Ongelmana on edelleen kuitenkin se, että kyseessä on monimutkainen ja erilaisia riippuvuussuhteita sisältävä järjestelmä jonka kokonaisuuden hahmottaminen ja optimoiminen manuaalisesti on hankalaa. Tämän harjoitustyön tarkoituksena on kehittää hahmojaon tueksi työkalu, joka tuottaa annettujen parametrien perusteella ehdotuksia yhteensopivuusprosenttien perusteella optimoiduiksi hahmojaoiksi, käyttäen hyväksi soveltuvia matemaattisia malleja ja niihin tehtyjä aineiston luonteeseen perustuvia optimointeja.

# Ongelman mallintaminen
Hahmojaossa kyse on kahteen erilliseen ryhmään (hahmot ja pelaajat) kuuluvien yksilöiden kohdistaminen toisiinsa niiden keskinäisiä suhteita kuvaavien attribuuttien perusteella. Tilannetta voidaan mallintaa suuntaamattomalla kaksijakoisella verkolla, jossa jaon toisen puolen solmut edustavat hahmoja ja toisen puolen solmut pelaajia. Näiden välisiä suhteita voidaan kuvata yhteensopivuusprosentilla painotetuilla kaarilla jotka yhdistävät jokaisen hahmon jokaiseen pelaajaan. Hahmojen ja pelaajien määrän ei ole pakko olla yhtä suuri, mutta käytännössä pelaajien määrä on aina suurempi kuin hahmojen määrä.

Koska kyseessä on käytännössä kaksiulotteinen matriisi, kaarten määrä on *p* × *h*, jossa *p* on pelaajien ja *h* hahmojen määrä, mikä tarkoittaa, että esimerkiksi 100 hahmon ja 150 ilmoittautuneen pelaajan tapauksessa kaarten määrä nousee helposti kohtuullisen suureksi algoritmeille, joiden aikavaativuus on O(n^2) tai korkeampi (kuten monissa tämäntapaisten ongelmien perinteisissä ratkaisuissa joita käsitellään alempana). Aineiston luonteesta johtuen verkkoa on kuitenkin mahdollista yksinkertaistaa jo sen syöttövaiheessa. Johtuen negatiivisille toiveille annetusta absoluuttisesta painotuksesta (eli pelaajalle ei haluta antaa hahmoa joka sisältää elementtejä joita tämä ei ehdottomasti halua pelata) aineisto sisältää runsaasti hahmo-pelaajapareja, joiden välinen yhteensopivuus on 0, mikä tarkoittaa, että näiden solmujen välille ei ole tarpeen luoda kaarta. Tästä johtuen luonnollisin esitysmuoto syötteelle on kohdesolmut ja näihin johtavien kaarien painot sisältävä vieruslista, jossa kunkin solmun naapurit on järjestetty niihin johtavan kaaren painon mukaan.

Aineiston pohjalta muodostetun kaksijakoisen verkon avulla annettu ongelma voidaan pyrkiä ratkaisemaan laskemalla eri algoritmeja käyttäen maksimiparitus, jossa jokainen hahmo yhdistyy yhteen pelaajaan siten, että joko kokonaisvirtaus tai yksittäisten kaarten virtaus kulloisessakin tapauksessa on mahdollisimman suuri. 

# Syöte ja käytettävät tietorakenteet
Työkalu saa syötteekseen yhteensopivuuslaskentaprosessin tuottaman TEI XML -muotoisen dokumentin, joka sisältää: 

1. *hahmolistan* jossa kunkin hahmon kohdalla on listattu kaikki pelaajat joiden yhteensopivuusprosentti on >0 yhteensopivuusprosentteineen , ja 
2. *pelaajalistan*, jossa on vastavuoroisesti listattu kunkin pelaajan kohdalla hahmot, joiden yhteensopivuusprosentti on >0 yhteensopivuusprosentteineen.

Koska ratkaistavan ongelman tapauksessa aikavaativuus on paljon suurempi ongelma kuin tilavaativuus, tallennetaan tieto osittain päällekkäisiin rakenteisiin siten, että kussakin tilanteessa voidaan käyttää hakuihin tehokkainta rakennetta. Hahmojen ja pelaajien tunnukset tallennetaan erillisiin taulukoihin, joiden indeksejä käytetään ohjelman sisällä niiden tunnuksena; indeksi 0 jätetään molemmissa taulukoissa tyhjäksi jotta sitä voidaan myöhemmin käyttää ilmaisemaan ettei jokin pelaaja yhdisty mihinkään hahmoon tai toisin päin. 

Hahmojen ja pelaajien väliset yhteensopivuusprosentit (ilmaistuna kokonaislukuarvoilla 0–100) tallennetaan kaksiulotteiseen taulukkoon, jossa rivin numero viittaa pelaajan indeksiin ja sarakkeen numero hahmon indeksiin. Koska tämä kaksiulotteinen taulukko sisältää todennäköisesti runsaasti arvoja 0 joka käytännössä tarkoittaa sitä, ettei hahmoa ja pelaajaa verkossa edustavien solmujen välillä ole kaarta, sen käyttö ei ole tehokasta silloin kun halutaan käydä läpi tietyn solmun kaikki naapurit. Tämän vuoksi jokaista pelaajaa ja hahmoa kuvaavalle solmulle tallennetaan erikseen vieruslista, joka sisältää vain ne vastapuolen solmut, joiden yhteensopivuus solmun kanssa on suurempi kuin 0. Nämä vieruslistat tallennetaan kahteen taulukkoon (hahmot ja pelaajat) jonka jokainen alkio sisältää viittauksen indeksin osoittaman solmun vieruslistan sisältävään taulukkolistaan (ArrayList), joka puolestaan sisältää kohdesolmun indeksin, jonka perusteella voidaan kaaren paino noutaa yllä mainitusta kaksiulotteisesta taulukosta. Eri algoritmit käyttävät lisäksi ajon aikana erilaisia taulukko- ja kokoelmarakenteita pitääkseen kirjaa suorituksen etenemisestä.

Kaikki käytetyt algoritmit tallentavat lopulta käsittelyn tulokset kaksiulotteiseen tulostaulukkoon, jonka jokainen rivi sisältää kolme alkiota: hahmon tunnuksen, sille valitun pelaajan tunnuksen ja näiden välisen yhteensopivuusprosentin. Nämä tulostaulukot, yhdessä tulosta ja sen laskentaa koskevien metatietojen kanssa, tulostetaan tekstikäyttöliittymään ja tallennetaan levylle käyttäjän valitsemassa muodossa.

# Käytettävät algoritmit
Ratkaistavana oleva ongelma on luonteeltaan paritusongelma, jonka triviaalit ratkaisut ovat aikavaativuudeltaan lähtökohtaisest n!, mikä sulkee pois sen käyttämisen (koska tyypillisissä käytännön tapauksissa *n* on välillä 30–100). Onneksi ongelma voidaan kuitenkin nähdä variaationa useammastakin klassisesta ohjelmointiongelmasta joihin puolestaan saattaa olla useita vakiintuneita ratkaisualgoritmeja, joihin voidaan lisäksi tehdä erilaisia aineiston erityispiirteet huomioon ottavia optimointeja. Tästä syystä työkalun on tarkoitus tarjota useita eri ratkaisualgoritmeja, joiden tuottamia tuloksia voidaan myös tarkastella rinnakkain ja vertailla. Erilaisten ratkaisualgoritmien lisäksi työkalu tulee sisältämään erilaisia käyttäjän valittavissa olevia algoritmien toimintaan vaikuttavia parametreja, aineiston erityispiirteisiin perustuvia optimointeja ja syötteen käsittelyyn vaikuttavia reunaehtoja.

## Vakaiden avioliittojen ongelma (Stable Marriage Problem)
Yhtäältä ratkaistavana oleva ongelma voidaan nähdä klassisen vakaiden avioliittojen ongelman erikoistapauksena, jossa toinen osapuoli voi olla ylijäämäinen eli kaikille kosijoille tai kosittaville ei löydy paria (riippuen siitä, määritelläänkö kosijoiksi pelaajat vai hahmot). Tämän ongelman tunnetuin ratkaisu on nk. Galen–Shapleyn algoritmi, joka perustuu kosinta-analogiaan, jossa ensimmäisen joukon jäsenet ("kosijat) tekevät "tarjouksia" toisen joukon jäsenille ("kosittaville") näiden mieluisuusjärjestyksessä, ja kosittavat puolestaan joko hylkäävät tai hyväksyvät toistaiseksi kunkin tarjouksen oman mieluisuusjärjestyksensä perusteella. Tätä jatketaan, kunnes syntyy tilanne jossa yhdenkään muodostuneen parin molemmat jäsenet eivät suosi yhtäkään parin ulkopuolista jäsentä. 

Koska Galen–Shapleyn algoritmi olettaa että kosittavien ja kosijoiden määrä on sama, sitä on tässä tapauksessa muokattava siten, että osa joko kosijoista tai kosittavista voi jäädä ilman paria ja kierrosta toistetaan vain kunnes pienemmän ryhmän kaikki jäsenet ovat pariutuneet. Vakaiden avioliittojen ongelmalle voi olla useita ratkaisuja, jotka ovat optimaalisia eri näkökulmista. Koska Galen–Shapleyn algoritmi tuottaa aina ratkaisun, joka priorisoi kosijoiden preferenssejä ja on siis optimoitu näiden kannalta, työkaluun toteutetaan mahdollisuus määrittää ratkaisu Galen–Shapleyn algoritmilla priorisoiden joko hahmoja (eli jokaiselle hahmolle haetaan sopivin mahdollinen pelaaja) tai pelaajia (eli jokaiselle pelaajalle haetaan sopivin mahdollinen hahmo) ja vertailla näiden tuottamia ratkaisuja.

## Kohdistusongelma (Assignment Problem)
Ratkaistavaa ongelmaa voidaan tarkastella myös enemmän kokonaisuuden kuin yksittäisten hahmojen ja pelaajien näkökulmasta ja pyrkiä optimoimaan hahmojaon kokonaissopivuutta, jolloin ongelma näyttäytyy kohdistusongelmana, jossa pyritään saamaan aikaan maksimiparitus, jossa verkon maksimivirtaus on mahdollisimman suuri. Yksinkertaisin ratkaisu tällaiseen ongelmaan on laskea kaikki mahdolliset vaihtoehdot ja vertailla niiden kokonaisvirtauksia, mutta koska tämän aikavaativuus on *n!* (jos sekä hahmojen että pelaajien määrä on *n*) ei tämä ole mahdollista tyypillisillä pelaaja- ja hahmomäärillä.

Onneksi kohdistusongelman ratkaisemiseen on kehitetty useitakin menetelmiä, joiden aikavaativuus on huomattavasti kohtuullisempi. Näistä työkalussa toteutetaan ensisijaisesti ns. "unkarilainen algoritmi", joka ei ole kovin tehokas, mutta yksinkertaisempi ja siten paremmin harjoituksen rajoihin mahtuva kuin siitä kehitetyt tehokkaammat variantit. Unkarilaisen algoritmin perusversion lisäksi työkaluun voidaan integroida sen kehittyneempiä versioita sikäli kuin niitä löytyy valmiina Java-kirjastoina. Unkarilaisen algoritmin lisäksi työkalussa toteutetaan vähintään yksi versio ns. huutokauppa-algoritmista ja mikäli ylimääräistä aikaa jää, myös muita lineaariseen ohjelmointiin perustuvia algoritmeja (jotka voivat jäädä myös myöhemmin toteutettaviksi lisäyksiksi).

# Aika- ja tilavaativuus
Työkalun yhtenä päätarkoituksena on tarjota käsiteltävälle ongelmalle useita erilaisia ratkaisumalleja ja mahdollistaa niiden vertailu, niin tulosten kuin tehokkuuenkin suhteen. Ongelman luonteesta johtuen käytännössä kaikki sen ratkaisemiseen soveltuvat algoritmit toimivat eksponentiaalisessa ajassa, mitä voidaan pitää hyväksyttävänä, koska käsiteltävässä ongelmassa syötteet ovat usein kohtuullisen pieniä (30 < n < 200). Vakaiden avioliittojen ongelman ratkaisuun käytettävän Galen–Shapleyn algoritmin aikavaativuus on O(nˆ2), kun taas yksinkertaisimman kohdistusongelman ratkaisualgoritmin eli unkarilaisen algoritmin aikavaativuus on lähtökohtaisesti O(n^4) ja parannellussa muodossaan O(n^3). Huutokauppa-algoritmin odotettu aikavaativuus sen sijaan on O(n^2 log n) eli hieman tätä parempi. Näin ollen työkalun aikavaativuus riippuu käyttäjän valitsemasta algoritmista ja mahdollisista sen yhteydessä käytetyistä aineiston erityispiirteisiin perustuvista optimoinneista, joiden testaaminen on yksi harjoitustehtävän päämääristä. Työkalun päämääränä on onnistua optimoimaan aineisto ja sen käsittely siten, että jopa aikavaativuudeltaan O(n^3) algoritmeja voidaan käyttää tyypillisille syötteille ilman, että käyttökokemus merkittävästi heikkenee.

Tilavaativuuden suhteen käytettävät menetelmät eivät ole erityisen vaativia ja syötteiden pieni koko tarkoittaa sitä, ettei tilavaativuuden optimointi myöskään ole kovin suuri prioriteetti.

# Ohjelman käyttö ja toiminta
Ohjelman käyttöliittymä tulee olemaan tekstimuotoinen, ja sen tarkoitus on lähinnä tarjota käyttäjälle tapa syöttää työkaluun toisaalla määritellyssä TEI XML-muodossa oleva syötetiedosto, valita käytettävä(t) algoritmi(t) ja määrittää niiden toimintaan vaikuttavia parametreja ja reunaehtoja. Kun käyttäjä on syöttänyt aineiston ja työkalu on tallentanut sen sisältämät tiedot yllä kuvattuihin tietorakenteisiin, käyttäjä valitsee ne algoritmit (variaatioineen), joita haluaa käyttää tulosten laskemiseen, jonka jälkeen käyttäjältä kysytään algoritmikohtaisia tarkentavia kysymyksiä käytettävistä parametreista ja reunaehdoista. Tämän jälkeen työkalu suorittaa valitut algoritmit ja sekä tulostaa tulokset käyttöliittymään että tallentaa ne käyttäjän valitsemassa muodossa levylle jatkokäsittelyä varten.

# Lähteet
(Tulossa myöhemmin.)
